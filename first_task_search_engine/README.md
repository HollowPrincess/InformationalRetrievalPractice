# Задание 1.

## Построение индекса.

**1. Сбор корпуса.**

Для выполнения задания были взяты данные о вопросах на тему *python* на *stackoverflow*. Данные были взяты на [kaggle](https://www.kaggle.com/stackoverflow/pythonquestions#Questions.csv). 

В качестве корпуса был взят только файл с вопросами (846.87Mb).

В качестве документа рассматривается строка таблицы. 

Для подготовки данных из таблицы были взяты только столбцы с заголовком и телом вопроса, для удобства столбцы с заголовком и с телом вопроса были объединены в один.

Затем был определен основной язык вопросов, после удаления вопросов на других языках осталось **772.8Mb** данных.

Было решено сократить число данных до **224 Mb** (100 000 документов перед определением языка) для упрощения исполнения здания с точки времени выполнения (построения индекса).

**2. Токенизация.**

На этапе токенизации текста из всех текстов были убраны **html-тэги** и **знаки пунктуации**, после чего текст был разбит на токены по пробельным символам.

**3. Лексическая обработка текста.**

Производится **лемматизация** токенов.

**4. Построение инвертированного индекса.**

Для хранения инвертированного индекса используется **defaultdict** - потомок [dict](https://github.com/python/cpython/blob/master/Objects/dictobject.c), который является реализацией hash-таблиц.

В качестве алгоритма построения был реализован [SPIMI](https://nlp.stanford.edu/IR-book/html/htmledition/single-pass-in-memory-indexing-1.html). 

Для упрощения итогового ранжирования, в индексе помимо идентификатора документа хранятся частоты терма в документе.

Блоки индекса мерджатся в один файл, после чего итоговый индекс бъется на части, оптимальные для выгрузки в оперативную память.

## Поисковая машина.

**1. Были написаны операции над *posting lists***

**1.1. AND** - пересечение двух posting lists

**1.2. OR** - объединение двух posting lists

**1.3. NOT** - вычитание из левого posting list правый posting list

**1.4. multi AND** - пересечение более, чем двух posting lists

**2. Написана обработка запроса**

Запрос соответствует формату *слово1 оператор1 слово2 оператор2 слово3* и т.д.
То есть запрос начинается со слова и слова чередуются с операторами.
Регистр слов и операторов не важен.
Операторы считываются в такой записи: and, or, not, &, |, ~.

# Задание 2.

## 2.1. Векторная модель.

Для построения эмбеддингов документов и запросов использовался **GloVeEmbedder** из **deeppavlov**.

В качестве меры близости двух векторов была взята косинусная мера близости.
Ранжирование документов производится по убыванию косинусной меры.

